<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \React\Async;
use \React\Promise\PromiseInterface;

class weex extends \ccxt\async\weex {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchOrderBook' => true,
                'watchTrades' => true,
                'watchTradesForSymbols' => false,
                'watchMyTrades' => true,
                'watchBalance' => true,
                'watchOHLCV' => true,
                'watchOrders' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://ws-spot.weex.com/v2/ws/public',
                        'private' => 'wss://ws-spot.weex.com/v2/ws/private',
                    ),
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'ordersLimit' => 1000,
                'OHLCVLimit' => 1000,
                'watchOrderBook' => array(
                    'depth' => 15, // 15 or 200
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 30000, // 30 seconds
            ),
        ));
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $url = $this->urls['api']['ws']['public'];
            $messageHash = 'ticker:' . $marketId;
            $channel = 'ticker.' . $marketId;
            $request = array(
                'event' => 'subscribe',
                'channel' => $channel,
            );
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * watches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int} [$since] timestamp in ms of the earliest candle to fetch
             * @param {int} [$limit] the maximum amount of candles to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int[][]} A list of candles ordered, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $interval = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $weexInterval = $this->timeframe_to_weex_interval($interval);
            $url = $this->urls['api']['ws']['public'];
            $messageHash = 'kline:' . $marketId . ':' . $interval;
            $channel = 'kline.LAST_PRICE.' . $marketId . '.' . $weexInterval;
            $request = array(
                'event' => 'subscribe',
                'channel' => $channel,
            );
            $ohlcv = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function timeframe_to_weex_interval(string $timeframe): string {
        $intervals = array(
            '1m' => 'MINUTE_1',
            '5m' => 'MINUTE_5',
            '15m' => 'MINUTE_15',
            '30m' => 'MINUTE_30',
            '1h' => 'HOUR_1',
            '2h' => 'HOUR_2',
            '4h' => 'HOUR_4',
            '6h' => 'HOUR_6',
            '8h' => 'HOUR_8',
            '12h' => 'HOUR_12',
            '1d' => 'DAY_1',
            '1w' => 'WEEK_1',
            '1M' => 'MONTH_1',
        );
        return $this->safe_string($intervals, $timeframe, $timeframe);
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $marketId = $market['id'];
            $url = $this->urls['api']['ws']['public'];
            $messageHash = 'trades:' . $marketId;
            $channel = 'trades.' . $marketId;
            $request = array(
                'event' => 'subscribe',
                'channel' => $channel,
            );
            $trades = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $marketId = $market['id'];
            $depth = $this->safe_integer($params, 'depth', $this->safe_integer($this->options['watchOrderBook'], 'depth', 15));
            $url = $this->urls['api']['ws']['public'];
            $messageHash = 'depth:' . $marketId;
            $channel = 'depth.' . $marketId . '.' . (string) $depth;
            $request = array(
                'event' => 'subscribe',
                'channel' => $channel,
            );
            $orderbook = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            return $orderbook->limit ();
        }) ();
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified $market $symbol of the $market $trades were made in
             * @param {int} [$since] the earliest time in ms to fetch $trades for
             * @param {int} [$limit] the maximum number of trade structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $messageHash = 'fill';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $messageHash .= ':' . $market['id'];
            }
            $url = $this->urls['api']['ws']['private'];
            $request = array(
                'event' => 'subscribe',
                'channel' => 'fill',
            );
            $trades = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $messageHash = 'orders';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $messageHash .= ':' . $market['id'];
            }
            $url = $this->urls['api']['ws']['private'];
            $request = array(
                'event' => 'subscribe',
                'channel' => 'orders',
            );
            $orders = Async\await($this->watch($url, $messageHash, $request, $messageHash));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * watch balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            Async\await($this->authenticate());
            $url = $this->urls['api']['ws']['private'];
            $messageHash = 'account';
            $request = array(
                'event' => 'subscribe',
                'channel' => 'account',
            );
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function authenticate($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            $this->check_required_credentials();
            $url = $this->urls['api']['ws']['private'];
            $client = $this->client($url);
            $messageHash = 'authenticated';
            $future = $this->safe_value($client->subscriptions, $messageHash);
            if ($future === null) {
                $future = $client->future ($messageHash);
                $client->subscriptions[$messageHash] = $future;
                // WEEX requires authentication headers to be set on connection
                // Authentication will be handled via the headers during WebSocket handshake
            }
            return Async\await($future);
        }) ();
    }

    public function handle_message(Client $client, mixed $message): mixed {
        if ($this->is_json_encoded_object($message)) {
            $event = $this->safe_string($message, 'event');
            if ($event === 'ping') {
                $this->handle_ping($client, $message);
                return;
            } elseif ($event === 'pong') {
                $this->handle_pong($client, $message);
                return;
            } elseif ($event === 'subscribed') {
                $this->handle_subscription_status($client, $message);
                return;
            } elseif ($event === 'unsubscribed') {
                $this->handle_subscription_status($client, $message);
                return;
            } elseif ($event === 'payload') {
                $this->handle_payload($client, $message);
                return;
            }
        }
        $type = $this->safe_string($message, 'type');
        if ($type === 'trade-event') {
            $this->handle_trade_event($client, $message);
        }
    }

    public function handle_ping(Client $client, mixed $message): mixed {
        $time = $this->safe_string($message, 'time');
        $client->send (array(
            'event' => 'pong',
            'time' => $time,
        ));
    }

    public function handle_pong(Client $client, mixed $message): mixed {
        // Handle pong response
        $client->lastPong = $this->milliseconds();
    }

    public function ping(Client $client): mixed {
        $time = (string) $this->milliseconds();
        return array(
            'event' => 'ping',
            'time' => $time,
        );
    }

    public function handle_subscription_status(Client $client, mixed $message): mixed {
        $event = $this->safe_string($message, 'event');
        if ($event === 'subscribed') {
            // Handle successful subscription
            // No additional handling needed for subscription confirmation
            $channel = $this->safe_string($message, 'channel');
            if ($channel) {
                // Successfully subscribed to $channel
                // Log subscription success if verbose mode is enabled
                if ($this->verbose) {
                    $this->log('Successfully subscribed to $channel:', $channel);
                }
            }
        }
    }

    public function handle_payload(Client $client, mixed $message): mixed {
        $channel = $this->safe_string($message, 'channel');
        if ($channel === null) {
            return;
        }
        if (mb_strpos($channel, 'ticker.') === 0) {
            $this->handle_ticker($client, $message);
        } elseif (mb_strpos($channel, 'kline.') === 0) {
            $this->handle_ohlcv($client, $message);
        } elseif (mb_strpos($channel, 'trades.') === 0) {
            $this->handle_trades($client, $message);
        } elseif (mb_strpos($channel, 'depth.') === 0) {
            $this->handle_order_book($client, $message);
        }
    }

    public function handle_trade_event(Client $client, mixed $message): mixed {
        $channel = $this->safe_string($message, 'channel');
        if ($channel === 'account') {
            $this->handle_balance($client, $message);
        } elseif ($channel === 'fill') {
            $this->handle_my_trades($client, $message);
        } elseif ($channel === 'orders') {
            $this->handle_orders($client, $message);
        }
    }

    public function handle_ticker(Client $client, mixed $message): mixed {
        //
        // {
        //   "event" => "payload",
        //   "channel" => "ticker.BTCUSDT_SPBL",
        //   "data" => array(
        //     {
        //       "symbol" => "BTCUSDT_SPBL",
        //       "priceChange" => "325.3",
        //       "priceChangePercent" => "0.003100",
        //       "trades" => "20894",
        //       "size" => "15930.189169",
        //       "value" => "1670098071.4896045",
        //       "high" => "106500.0",
        //       "low" => "93128.9",
        //       "lastPrice" => "105252.1",
        //       "markPrice" => "0"
        //     }
        //   )
        // }
        //
        $data = $this->safe_list($message, 'data', array());
        if (strlen($data) > 0) {
            $tickerData = $data[0];
            $marketId = $this->safe_string($tickerData, 'symbol');
            $market = $this->safe_market($marketId);
            $ticker = $this->parse_ticker($tickerData, $market);
            $messageHash = 'ticker:' . $marketId;
            $client->resolve ($ticker, $messageHash);
        }
    }

    public function handle_ohlcv(Client $client, mixed $message): mixed {
        //
        // {
        //   "event" => "payload",
        //   "channel" => "kline.LAST_PRICE.BTCUSDT_SPBL.MINUTE_1",
        //   "data" => array(
        //     {
        //       "startTime" => 1693208170000,
        //       "open" => "35000.5",
        //       "high" => "35100.0",
        //       "low" => "34900.0",
        //       "close" => "35050.0",
        //       "volume" => "150.5"
        //     }
        //   )
        // }
        //
        $channel = $this->safe_string($message, 'channel');
        $parts = explode('.', $channel);
        $marketId = $this->safe_string($parts, 2);
        $intervalPart = $this->safe_string($parts, 3);
        $interval = $this->weex_interval_to_timeframe($intervalPart);
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $data = $this->safe_list($message, 'data', array());
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $stored = $this->safe_value($this->ohlcvs[$symbol], $interval);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$interval] = $stored;
        }
        for ($i = 0; $i < count($data); $i++) {
            $ohlcv = $data[$i];
            $parsed = $this->parse_ws_ohlcv($ohlcv, $market);
            $stored->append ($parsed);
        }
        $messageHash = 'kline:' . $marketId . ':' . $interval;
        $client->resolve ($stored, $messageHash);
    }

    public function weex_interval_to_timeframe(string $interval): string {
        $timeframes = array(
            'MINUTE_1' => '1m',
            'MINUTE_5' => '5m',
            'MINUTE_15' => '15m',
            'MINUTE_30' => '30m',
            'HOUR_1' => '1h',
            'HOUR_2' => '2h',
            'HOUR_4' => '4h',
            'HOUR_6' => '6h',
            'HOUR_8' => '8h',
            'HOUR_12' => '12h',
            'DAY_1' => '1d',
            'WEEK_1' => '1w',
            'MONTH_1' => '1M',
        );
        return $this->safe_string($timeframes, $interval, $interval);
    }

    public function parse_ws_ohlcv(mixed $ohlcv, mixed $market = null): array {
        //
        // {
        //   "startTime" => 1693208170000,
        //   "open" => "35000.5",
        //   "high" => "35100.0",
        //   "low" => "34900.0",
        //   "close" => "35050.0",
        //   "volume" => "150.5"
        // }
        //
        return array(
            $this->safe_integer($ohlcv, 'startTime'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'volume'),
        );
    }

    public function handle_trades(Client $client, mixed $message): mixed {
        //
        // {
        //   "event" => "payload",
        //   "channel" => "trades.BTCUSDT_SPBL",
        //   "data" => array(
        //     {
        //       "time" => "1747131727502",
        //       "price" => "103337.5",
        //       "size" => "0.01600",
        //       "value" => "1653.400000",
        //       "buyerMaker" => false
        //     }
        //   )
        // }
        //
        $channel = $this->safe_string($message, 'channel');
        $parts = explode('.', $channel);
        $marketId = $this->safe_string($parts, 1);
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $data = $this->safe_list($message, 'data', array());
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        for ($i = 0; $i < count($data); $i++) {
            $trade = $data[$i];
            $parsed = $this->parse_ws_trade($trade, $market);
            $stored->append ($parsed);
        }
        $messageHash = 'trades:' . $marketId;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_trade(mixed $trade, mixed $market = null): array {
        //
        // {
        //   "time" => "1747131727502",
        //   "price" => "103337.5",
        //   "size" => "0.01600",
        //   "value" => "1653.400000",
        //   "buyerMaker" => false
        // }
        //
        $timestamp = $this->safe_integer($trade, 'time');
        $priceString = $this->safe_string($trade, 'price');
        $amountString = $this->safe_string($trade, 'size');
        $costString = $this->safe_string($trade, 'value');
        $buyerMaker = $this->safe_value($trade, 'buyerMaker');
        $side = $buyerMaker ? 'sell' : 'buy'; // If buyer is maker, then this $trade is a sell
        $symbol = $this->safe_string($market, 'symbol');
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => null,
            'order' => null,
            'type' => null,
            'takerOrMaker' => $buyerMaker ? 'maker' : 'taker',
            'side' => $side,
            'amount' => $amountString,
            'price' => $priceString,
            'cost' => $costString,
            'fee' => null,
        ), $market);
    }

    public function handle_order_book(Client $client, mixed $message): mixed {
        //
        // {
        //   "event" => "payload",
        //   "channel" => "depth.BTCUSDT_SPBL.15",
        //   "data" => array(
        //     {
        //       "startVersion" => "3644174246",
        //       "endVersion" => "3644174270",
        //       "level" => 15,
        //       "depthType" => "CHANGED",
        //       "symbol" => "BTCUSDT_SPBL",
        //       "asks" => array(
        //         {
        //           "price" => "103436.1",
        //           "size" => "0.91500"
        //         }
        //       ),
        //       "bids" => array(
        //         {
        //           "price" => "103435.9",
        //           "size" => "2.40500"
        //         }
        //       )
        //     }
        //   )
        // }
        //
        $channel = $this->safe_string($message, 'channel');
        $parts = explode('.', $channel);
        $marketId = $this->safe_string($parts, 1);
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $data = $this->safe_list($message, 'data', array());
        if (strlen($data) > 0) {
            $orderBookData = $data[0];
            $depthType = $this->safe_string($orderBookData, 'depthType');
            if ($depthType === 'SNAPSHOT') {
                $snapshot = $this->parse_order_book($orderBookData, $symbol);
                $orderbook = $this->order_book($snapshot);
                $this->orderbooks[$symbol] = $orderbook;
            } elseif ($depthType === 'CHANGED') {
                if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
                    return;
                }
                $orderbook = $this->orderbooks[$symbol];
                $asks = $this->safe_list($orderBookData, 'asks', array());
                $bids = $this->safe_list($orderBookData, 'bids', array());
                $this->handle_deltas($orderbook['asks'], $asks);
                $this->handle_deltas($orderbook['bids'], $bids);
                $orderbook['timestamp'] = $this->milliseconds();
                $orderbook['datetime'] = $this->iso8601($orderbook['timestamp']);
            }
            $messageHash = 'depth:' . $marketId;
            $client->resolve ($this->orderbooks[$symbol], $messageHash);
        }
    }

    public function handle_deltas(mixed $bookside, array $deltas): void {
        for ($i = 0; $i < count($deltas); $i++) {
            $delta = $deltas[$i];
            $price = $this->safe_number($delta, 'price');
            $size = $this->safe_number($delta, 'size');
            if ($size === 0) {
                unset($bookside[$price]);
            } else {
                $bookside[$price] = $size;
            }
        }
    }

    public function handle_my_trades(Client $client, mixed $message): mixed {
        //
        // {
        //   "type" => "trade-event",
        //   "channel" => "fill",
        //   "msg" => {
        //     "msgEvent" => "OrderUpdate",
        //     "version" => 38,
        //     "data" => array(
        //       "orderFillTransaction" => array(
        //         array(
        //           "id" => "625138763437179034",
        //           "symbolName" => "BTCUSDT_SPBL",
        //           "baseCoin" => "BTC",
        //           "quoteCoin" => "USDT",
        //           "orderId" => "625138763307155610",
        //           "orderSide" => "BUY",
        //           "fillSize" => "0.000952",
        //           "fillValue" => "99.9676160",
        //           "fillFee" => "0.00000095",
        //           "direction" => "TAKER",
        //           "createdTime" => "1749044695720",
        //           "updatedTime" => "1749044695720"
        //         }
        //       )
        //     ),
        //     "time" => 1749044695720
        //   ),
        //   "event" => "payload"
        // }
        //
        $msg = $this->safe_dict($message, 'msg', array());
        $data = $this->safe_dict($msg, 'data', array());
        $fills = $this->safe_list($data, 'orderFillTransaction', array());
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCacheBySymbolById ($limit);
        }
        $tradesArray = $this->myTrades;
        for ($i = 0; $i < count($fills); $i++) {
            $fill = $fills[$i];
            $trade = $this->parse_ws_my_trade($fill);
            $tradesArray->append ($trade);
        }
        $client->resolve ($tradesArray, 'fill');
        // Resolve symbol-specific subscriptions
        for ($i = 0; $i < count($fills); $i++) {
            $fill = $fills[$i];
            $marketId = $this->safe_string($fill, 'symbolName');
            $messageHash = 'fill:' . $marketId;
            $client->resolve ($tradesArray, $messageHash);
        }
    }

    public function parse_ws_my_trade(mixed $trade): array {
        //
        // {
        //   "id" => "625138763437179034",
        //   "symbolName" => "BTCUSDT_SPBL",
        //   "baseCoin" => "BTC",
        //   "quoteCoin" => "USDT",
        //   "orderId" => "625138763307155610",
        //   "orderSide" => "BUY",
        //   "fillSize" => "0.000952",
        //   "fillValue" => "99.9676160",
        //   "fillFee" => "0.00000095",
        //   "direction" => "TAKER",
        //   "createdTime" => "1749044695720",
        //   "updatedTime" => "1749044695720"
        // }
        //
        $id = $this->safe_string($trade, 'id');
        $orderId = $this->safe_string($trade, 'orderId');
        $marketId = $this->safe_string($trade, 'symbolName');
        $market = $this->safe_market($marketId);
        $symbol = $this->safe_string($market, 'symbol');
        $timestamp = $this->safe_integer($trade, 'createdTime');
        $side = $this->safe_string_lower($trade, 'orderSide');
        $amount = $this->safe_string($trade, 'fillSize');
        $cost = $this->safe_string($trade, 'fillValue');
        $feeAmount = $this->safe_string($trade, 'fillFee');
        $direction = $this->safe_string_lower($trade, 'direction');
        $takerOrMaker = ($direction === 'taker') ? 'taker' : 'maker';
        $baseCurrency = $this->safe_string($trade, 'baseCoin');
        $fee = array(
            'cost' => $feeAmount,
            'currency' => $baseCurrency,
        );
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => null,
            'side' => $side,
            'amount' => $amount,
            'price' => null,
            'cost' => $cost,
            'takerOrMaker' => $takerOrMaker,
            'fee' => $fee,
        ), $market);
    }

    public function handle_orders(Client $client, mixed $message): mixed {
        //
        // {
        //   "type" => "trade-event",
        //   "channel" => "orders",
        //   "msg" => {
        //     "msgEvent" => "OrderUpdate",
        //     "version" => 38,
        //     "data" => array(
        //       "order" => array(
        //         array(
        //           "id" => "625138763307155610",
        //           "symbolName" => "BTCUSDT_SPBL",
        //           "baseCoin" => "BTC",
        //           "quoteCoin" => "USDT",
        //           "orderSide" => "BUY",
        //           "price" => "0",
        //           "size" => "0",
        //           "value" => "100.0000000",
        //           "clientOrderId" => "1749044695347g1xrdKa2xuDzbDHgTTkbubUoRd3x7s9c2I2mdtdj5qt7M6Evz5m",
        //           "type" => "MARKET",
        //           "timeInForce" => "IMMEDIATE_OR_CANCEL",
        //           "status" => "FILLED",
        //           "cumFillSize" => "0.000952",
        //           "cumFillValue" => "99.9676160",
        //           "cumFillFee" => "0.00000095",
        //           "createdTime" => "1749044695689",
        //           "updatedTime" => "1749044695720"
        //         }
        //       )
        //     ),
        //     "time" => 1749044695720
        //   ),
        //   "event" => "payload"
        // }
        //
        $msg = $this->safe_dict($message, 'msg', array());
        $data = $this->safe_dict($msg, 'data', array());
        $orders = $this->safe_list($data, 'order', array());
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $ordersArray = $this->orders;
        for ($i = 0; $i < count($orders); $i++) {
            $order = $orders[$i];
            $parsedOrder = $this->parse_ws_order($order);
            $ordersArray->append ($parsedOrder);
        }
        $client->resolve ($ordersArray, 'orders');
        // Resolve symbol-specific subscriptions
        for ($i = 0; $i < count($orders); $i++) {
            $order = $orders[$i];
            $marketId = $this->safe_string($order, 'symbolName');
            $messageHash = 'orders:' . $marketId;
            $client->resolve ($ordersArray, $messageHash);
        }
    }

    public function parse_ws_order(mixed $order): array {
        //
        // {
        //   "id" => "625138763307155610",
        //   "symbolName" => "BTCUSDT_SPBL",
        //   "baseCoin" => "BTC",
        //   "quoteCoin" => "USDT",
        //   "orderSide" => "BUY",
        //   "price" => "0",
        //   "size" => "0",
        //   "value" => "100.0000000",
        //   "clientOrderId" => "1749044695347g1xrdKa2xuDzbDHgTTkbubUoRd3x7s9c2I2mdtdj5qt7M6Evz5m",
        //   "type" => "MARKET",
        //   "timeInForce" => "IMMEDIATE_OR_CANCEL",
        //   "status" => "FILLED",
        //   "cumFillSize" => "0.000952",
        //   "cumFillValue" => "99.9676160",
        //   "cumFillFee" => "0.00000095",
        //   "createdTime" => "1749044695689",
        //   "updatedTime" => "1749044695720"
        // }
        //
        $id = $this->safe_string($order, 'id');
        $clientOrderId = $this->safe_string($order, 'clientOrderId');
        $marketId = $this->safe_string($order, 'symbolName');
        $market = $this->safe_market($marketId);
        $symbol = $this->safe_string($market, 'symbol');
        $timestamp = $this->safe_integer($order, 'createdTime');
        $lastUpdateTimestamp = $this->safe_integer($order, 'updatedTime');
        $type = $this->safe_string_lower($order, 'type');
        $side = $this->safe_string_lower($order, 'orderSide');
        $amount = $this->safe_string_2($order, 'size', 'value'); // Use value for $market orders
        $price = $this->safe_string($order, 'price');
        $filled = $this->safe_string($order, 'cumFillSize');
        $cost = $this->safe_string($order, 'cumFillValue');
        $fee = array(
            'cost' => $this->safe_string($order, 'cumFillFee'),
            'currency' => $this->safe_string($order, 'baseCoin'),
        );
        $status = $this->safe_string_lower($order, 'status');
        // Map WEEX $status to CCXT $status
        if ($status === 'new' || $status === 'open') {
            $status = 'open';
        } elseif ($status === 'filled') {
            $status = 'closed';
        } elseif ($status === 'canceled' || $status === 'cancelled') {
            $status = 'canceled';
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastUpdateTimestamp,
            'lastUpdateTimestamp' => $lastUpdateTimestamp,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'amount' => $amount,
            'price' => $price,
            'stopPrice' => null,
            'triggerPrice' => null,
            'cost' => $cost,
            'average' => null,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
        ), $market);
    }

    public function handle_balance(Client $client, mixed $message): mixed {
        //
        // {
        //   "type" => "trade-event",
        //   "msg" => {
        //     "msgEvent" => "OrderUpdate",
        //     "version" => 38,
        //     "data" => array(
        //       "accountAsset" => array(
        //         array(
        //           "coinId" => 1,
        //           "coinName" => "BTC",
        //           "equity" => "3.042645318000",
        //           "available" => "3.042645318000",
        //           "frozen" => "0"
        //         }
        //       )
        //     ),
        //     "time" => 1749044695720
        //   ),
        //   "channel" => "account",
        //   "event" => "payload"
        // }
        //
        $msg = $this->safe_dict($message, 'msg', array());
        $data = $this->safe_dict($msg, 'data', array());
        $assets = $this->safe_list($data, 'accountAsset', array());
        $result = array(
            'info' => $message,
            'timestamp' => $this->safe_integer($msg, 'time'),
            'datetime' => null,
        );
        $result['datetime'] = $this->iso8601($result['timestamp']);
        for ($i = 0; $i < count($assets); $i++) {
            $asset = $assets[$i];
            $currencyId = $this->safe_string($asset, 'coinName');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['free'] = $this->safe_string($asset, 'available');
            $account['used'] = $this->safe_string($asset, 'frozen');
            $account['total'] = $this->safe_string($asset, 'equity');
            $result[$code] = $account;
        }
        $balance = $this->safe_balance($result);
        $client->resolve ($balance, 'account');
    }
}
