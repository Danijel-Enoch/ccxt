# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support
from ccxt.async_support.base.ws.cache import ArrayCache, ArrayCacheBySymbolById, ArrayCacheByTimestamp
from ccxt.base.types import Any, Balances, Int, Order, OrderBook, Str, Ticker, Trade
from ccxt.async_support.base.ws.client import Client
from typing import List


class weex(ccxt.async_support.weex):

    def describe(self) -> Any:
        return self.deep_extend(super(weex, self).describe(), {
            'has': {
                'ws': True,
                'watchTicker': True,
                'watchTickers': False,
                'watchOrderBook': True,
                'watchTrades': True,
                'watchTradesForSymbols': False,
                'watchMyTrades': True,
                'watchBalance': True,
                'watchOHLCV': True,
                'watchOrders': True,
            },
            'urls': {
                'api': {
                    'ws': {
                        'public': 'wss://ws-spot.weex.com/v2/ws/public',
                        'private': 'wss://ws-spot.weex.com/v2/ws/private',
                    },
                },
            },
            'options': {
                'tradesLimit': 1000,
                'ordersLimit': 1000,
                'OHLCVLimit': 1000,
                'watchOrderBook': {
                    'depth': 15,  # 15 or 200
                },
            },
            'streaming': {
                'ping': self.ping,
                'keepAlive': 30000,  # 30 seconds
            },
        })

    async def watch_ticker(self, symbol: str, params={}) -> Ticker:
        """
        watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        marketId = market['id']
        url = self.urls['api']['ws']['public']
        messageHash = 'ticker:' + marketId
        channel = 'ticker.' + marketId
        request: dict = {
            'event': 'subscribe',
            'channel': channel,
        }
        return await self.watch(url, messageHash, request, messageHash)

    async def watch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        """
        watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns int[][]: A list of candles ordered, open, high, low, close, volume
        """
        await self.load_markets()
        market = self.market(symbol)
        symbol = market['symbol']
        marketId = market['id']
        interval = self.safe_string(self.timeframes, timeframe, timeframe)
        weexInterval = self.timeframe_to_weex_interval(interval)
        url = self.urls['api']['ws']['public']
        messageHash = 'kline:' + marketId + ':' + interval
        channel = 'kline.LAST_PRICE.' + marketId + '.' + weexInterval
        request: dict = {
            'event': 'subscribe',
            'channel': channel,
        }
        ohlcv = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = ohlcv.getLimit(symbol, limit)
        return self.filter_by_since_limit(ohlcv, since, limit, 0, True)

    def timeframe_to_weex_interval(self, timeframe: str) -> str:
        intervals: dict = {
            '1m': 'MINUTE_1',
            '5m': 'MINUTE_5',
            '15m': 'MINUTE_15',
            '30m': 'MINUTE_30',
            '1h': 'HOUR_1',
            '2h': 'HOUR_2',
            '4h': 'HOUR_4',
            '6h': 'HOUR_6',
            '8h': 'HOUR_8',
            '12h': 'HOUR_12',
            '1d': 'DAY_1',
            '1w': 'WEEK_1',
            '1M': 'MONTH_1',
        }
        return self.safe_string(intervals, timeframe, timeframe)

    async def watch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=public-trades>`
        """
        await self.load_markets()
        market = self.market(symbol)
        symbol = market['symbol']
        marketId = market['id']
        url = self.urls['api']['ws']['public']
        messageHash = 'trades:' + marketId
        channel = 'trades.' + marketId
        request: dict = {
            'event': 'subscribe',
            'channel': channel,
        }
        trades = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_since_limit(trades, since, limit, 'timestamp', True)

    async def watch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        """
        watches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        marketId = market['id']
        depth = self.safe_integer(params, 'depth', self.safe_integer(self.options['watchOrderBook'], 'depth', 15))
        url = self.urls['api']['ws']['public']
        messageHash = 'depth:' + marketId
        channel = 'depth.' + marketId + '.' + str(depth)
        request: dict = {
            'event': 'subscribe',
            'channel': channel,
        }
        orderbook = await self.watch(url, messageHash, request, messageHash)
        return orderbook.limit()

    async def watch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        watches information on multiple trades made by the user
        :param str symbol: unified market symbol of the market trades were made in
        :param int [since]: the earliest time in ms to fetch trades for
        :param int [limit]: the maximum number of trade structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        await self.load_markets()
        await self.authenticate()
        messageHash = 'fill'
        if symbol is not None:
            market = self.market(symbol)
            messageHash += ':' + market['id']
        url = self.urls['api']['ws']['private']
        request: dict = {
            'event': 'subscribe',
            'channel': 'fill',
        }
        trades = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(trades, symbol, since, limit, True)

    async def watch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        watches information on multiple orders made by the user
        :param str symbol: unified market symbol of the market orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        await self.authenticate()
        messageHash = 'orders'
        if symbol is not None:
            market = self.market(symbol)
            messageHash += ':' + market['id']
        url = self.urls['api']['ws']['private']
        request: dict = {
            'event': 'subscribe',
            'channel': 'orders',
        }
        orders = await self.watch(url, messageHash, request, messageHash)
        if self.newUpdates:
            limit = orders.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit, True)

    async def watch_balance(self, params={}) -> Balances:
        """
        watch balance and get the amount of funds available for trading or funds locked in orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/#/?id=balance-structure>`
        """
        await self.load_markets()
        await self.authenticate()
        url = self.urls['api']['ws']['private']
        messageHash = 'account'
        request: dict = {
            'event': 'subscribe',
            'channel': 'account',
        }
        return await self.watch(url, messageHash, request, messageHash)

    async def authenticate(self, params={}) -> Any:
        self.check_required_credentials()
        url = self.urls['api']['ws']['private']
        client = self.client(url)
        messageHash = 'authenticated'
        future = self.safe_value(client.subscriptions, messageHash)
        if future is None:
            future = client.future(messageHash)
            client.subscriptions[messageHash] = future
            # WEEX requires authentication headers to be set on connection
            # Authentication will be handled via the headers during WebSocket handshake
        return await future

    def handle_message(self, client: Client, message: Any) -> Any:
        if self.is_json_encoded_object(message):
            event = self.safe_string(message, 'event')
            if event == 'ping':
                self.handle_ping(client, message)
                return
            elif event == 'pong':
                self.handle_pong(client, message)
                return
            elif event == 'subscribed':
                self.handle_subscription_status(client, message)
                return
            elif event == 'unsubscribed':
                self.handle_subscription_status(client, message)
                return
            elif event == 'payload':
                self.handle_payload(client, message)
                return
        type = self.safe_string(message, 'type')
        if type == 'trade-event':
            self.handle_trade_event(client, message)

    def handle_ping(self, client: Client, message: Any) -> Any:
        time = self.safe_string(message, 'time')
        client.send({
            'event': 'pong',
            'time': time,
        })

    def handle_pong(self, client: Client, message: Any) -> Any:
        # Handle pong response
        client.lastPong = self.milliseconds()

    def ping(self, client: Client) -> Any:
        time = str(self.milliseconds())
        return {
            'event': 'ping',
            'time': time,
        }

    def handle_subscription_status(self, client: Client, message: Any) -> Any:
        event = self.safe_string(message, 'event')
        if event == 'subscribed':
            # Handle successful subscription
            # No additional handling needed for subscription confirmation
            channel = self.safe_string(message, 'channel')
            if channel:
                # Successfully subscribed to channel
                # Log subscription success if verbose mode is enabled
                if self.verbose:
                    self.log('Successfully subscribed to channel:', channel)

    def handle_payload(self, client: Client, message: Any) -> Any:
        channel = self.safe_string(message, 'channel')
        if channel is None:
            return
        if channel.find('ticker.') == 0:
            self.handle_ticker(client, message)
        elif channel.find('kline.') == 0:
            self.handle_ohlcv(client, message)
        elif channel.find('trades.') == 0:
            self.handle_trades(client, message)
        elif channel.find('depth.') == 0:
            self.handle_order_book(client, message)

    def handle_trade_event(self, client: Client, message: Any) -> Any:
        channel = self.safe_string(message, 'channel')
        if channel == 'account':
            self.handle_balance(client, message)
        elif channel == 'fill':
            self.handle_my_trades(client, message)
        elif channel == 'orders':
            self.handle_orders(client, message)

    def handle_ticker(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "event": "payload",
        #   "channel": "ticker.BTCUSDT_SPBL",
        #   "data": [
        #     {
        #       "symbol": "BTCUSDT_SPBL",
        #       "priceChange": "325.3",
        #       "priceChangePercent": "0.003100",
        #       "trades": "20894",
        #       "size": "15930.189169",
        #       "value": "1670098071.4896045",
        #       "high": "106500.0",
        #       "low": "93128.9",
        #       "lastPrice": "105252.1",
        #       "markPrice": "0"
        #     }
        #   ]
        # }
        #
        data = self.safe_list(message, 'data', [])
        if len(data) > 0:
            tickerData = data[0]
            marketId = self.safe_string(tickerData, 'symbol')
            market = self.safe_market(marketId)
            ticker = self.parse_ticker(tickerData, market)
            messageHash = 'ticker:' + marketId
            client.resolve(ticker, messageHash)

    def handle_ohlcv(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "event": "payload",
        #   "channel": "kline.LAST_PRICE.BTCUSDT_SPBL.MINUTE_1",
        #   "data": [
        #     {
        #       "startTime": 1693208170000,
        #       "open": "35000.5",
        #       "high": "35100.0",
        #       "low": "34900.0",
        #       "close": "35050.0",
        #       "volume": "150.5"
        #     }
        #   ]
        # }
        #
        channel = self.safe_string(message, 'channel')
        parts = channel.split('.')
        marketId = self.safe_string(parts, 2)
        intervalPart = self.safe_string(parts, 3)
        interval = self.weex_interval_to_timeframe(intervalPart)
        market = self.safe_market(marketId)
        symbol = market['symbol']
        data = self.safe_list(message, 'data', [])
        self.ohlcvs[symbol] = self.safe_value(self.ohlcvs, symbol, {})
        stored = self.safe_value(self.ohlcvs[symbol], interval)
        if stored is None:
            limit = self.safe_integer(self.options, 'OHLCVLimit', 1000)
            stored = ArrayCacheByTimestamp(limit)
            self.ohlcvs[symbol][interval] = stored
        for i in range(0, len(data)):
            ohlcv = data[i]
            parsed = self.parse_ws_ohlcv(ohlcv, market)
            stored.append(parsed)
        messageHash = 'kline:' + marketId + ':' + interval
        client.resolve(stored, messageHash)

    def weex_interval_to_timeframe(self, interval: str) -> str:
        timeframes: dict = {
            'MINUTE_1': '1m',
            'MINUTE_5': '5m',
            'MINUTE_15': '15m',
            'MINUTE_30': '30m',
            'HOUR_1': '1h',
            'HOUR_2': '2h',
            'HOUR_4': '4h',
            'HOUR_6': '6h',
            'HOUR_8': '8h',
            'HOUR_12': '12h',
            'DAY_1': '1d',
            'WEEK_1': '1w',
            'MONTH_1': '1M',
        }
        return self.safe_string(timeframes, interval, interval)

    def parse_ws_ohlcv(self, ohlcv: Any, market: Any = None) -> list:
        #
        # {
        #   "startTime": 1693208170000,
        #   "open": "35000.5",
        #   "high": "35100.0",
        #   "low": "34900.0",
        #   "close": "35050.0",
        #   "volume": "150.5"
        # }
        #
        return [
            self.safe_integer(ohlcv, 'startTime'),
            self.safe_number(ohlcv, 'open'),
            self.safe_number(ohlcv, 'high'),
            self.safe_number(ohlcv, 'low'),
            self.safe_number(ohlcv, 'close'),
            self.safe_number(ohlcv, 'volume'),
        ]

    def handle_trades(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "event": "payload",
        #   "channel": "trades.BTCUSDT_SPBL",
        #   "data": [
        #     {
        #       "time": "1747131727502",
        #       "price": "103337.5",
        #       "size": "0.01600",
        #       "value": "1653.400000",
        #       "buyerMaker": False
        #     }
        #   ]
        # }
        #
        channel = self.safe_string(message, 'channel')
        parts = channel.split('.')
        marketId = self.safe_string(parts, 1)
        market = self.safe_market(marketId)
        symbol = market['symbol']
        data = self.safe_list(message, 'data', [])
        stored = self.safe_value(self.trades, symbol)
        if stored is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            stored = ArrayCache(limit)
            self.trades[symbol] = stored
        for i in range(0, len(data)):
            trade = data[i]
            parsed = self.parse_ws_trade(trade, market)
            stored.append(parsed)
        messageHash = 'trades:' + marketId
        client.resolve(stored, messageHash)

    def parse_ws_trade(self, trade: Any, market: Any = None) -> Trade:
        #
        # {
        #   "time": "1747131727502",
        #   "price": "103337.5",
        #   "size": "0.01600",
        #   "value": "1653.400000",
        #   "buyerMaker": False
        # }
        #
        timestamp = self.safe_integer(trade, 'time')
        priceString = self.safe_string(trade, 'price')
        amountString = self.safe_string(trade, 'size')
        costString = self.safe_string(trade, 'value')
        buyerMaker = self.safe_value(trade, 'buyerMaker')
        side = 'sell' if buyerMaker else 'buy'  # If buyer is maker, then self trade is a sell
        symbol = self.safe_string(market, 'symbol')
        return self.safe_trade({
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': None,
            'order': None,
            'type': None,
            'takerOrMaker': 'maker' if buyerMaker else 'taker',
            'side': side,
            'amount': amountString,
            'price': priceString,
            'cost': costString,
            'fee': None,
        }, market)

    def handle_order_book(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "event": "payload",
        #   "channel": "depth.BTCUSDT_SPBL.15",
        #   "data": [
        #     {
        #       "startVersion": "3644174246",
        #       "endVersion": "3644174270",
        #       "level": 15,
        #       "depthType": "CHANGED",
        #       "symbol": "BTCUSDT_SPBL",
        #       "asks": [
        #         {
        #           "price": "103436.1",
        #           "size": "0.91500"
        #         }
        #       ],
        #       "bids": [
        #         {
        #           "price": "103435.9",
        #           "size": "2.40500"
        #         }
        #       ]
        #     }
        #   ]
        # }
        #
        channel = self.safe_string(message, 'channel')
        parts = channel.split('.')
        marketId = self.safe_string(parts, 1)
        market = self.safe_market(marketId)
        symbol = market['symbol']
        data = self.safe_list(message, 'data', [])
        if len(data) > 0:
            orderBookData = data[0]
            depthType = self.safe_string(orderBookData, 'depthType')
            if depthType == 'SNAPSHOT':
                snapshot = self.parse_order_book(orderBookData, symbol)
                orderbook = self.order_book(snapshot)
                self.orderbooks[symbol] = orderbook
            elif depthType == 'CHANGED':
                if not (symbol in self.orderbooks):
                    return
                orderbook = self.orderbooks[symbol]
                asks = self.safe_list(orderBookData, 'asks', [])
                bids = self.safe_list(orderBookData, 'bids', [])
                self.handle_deltas(orderbook['asks'], asks)
                self.handle_deltas(orderbook['bids'], bids)
                orderbook['timestamp'] = self.milliseconds()
                orderbook['datetime'] = self.iso8601(orderbook['timestamp'])
            messageHash = 'depth:' + marketId
            client.resolve(self.orderbooks[symbol], messageHash)

    def handle_deltas(self, bookside: Any, deltas: List[Any]):
        for i in range(0, len(deltas)):
            delta = deltas[i]
            price = self.safe_number(delta, 'price')
            size = self.safe_number(delta, 'size')
            if size == 0:
                del bookside[price]
            else:
                bookside[price] = size

    def handle_my_trades(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "type": "trade-event",
        #   "channel": "fill",
        #   "msg": {
        #     "msgEvent": "OrderUpdate",
        #     "version": 38,
        #     "data": {
        #       "orderFillTransaction": [
        #         {
        #           "id": "625138763437179034",
        #           "symbolName": "BTCUSDT_SPBL",
        #           "baseCoin": "BTC",
        #           "quoteCoin": "USDT",
        #           "orderId": "625138763307155610",
        #           "orderSide": "BUY",
        #           "fillSize": "0.000952",
        #           "fillValue": "99.9676160",
        #           "fillFee": "0.00000095",
        #           "direction": "TAKER",
        #           "createdTime": "1749044695720",
        #           "updatedTime": "1749044695720"
        #         }
        #       ]
        #     },
        #     "time": 1749044695720
        #   },
        #   "event": "payload"
        # }
        #
        msg = self.safe_dict(message, 'msg', {})
        data = self.safe_dict(msg, 'data', {})
        fills = self.safe_list(data, 'orderFillTransaction', [])
        if self.myTrades is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            self.myTrades = ArrayCacheBySymbolById(limit)
        tradesArray = self.myTrades
        for i in range(0, len(fills)):
            fill = fills[i]
            trade = self.parse_ws_my_trade(fill)
            tradesArray.append(trade)
        client.resolve(tradesArray, 'fill')
        # Resolve symbol-specific subscriptions
        for i in range(0, len(fills)):
            fill = fills[i]
            marketId = self.safe_string(fill, 'symbolName')
            messageHash = 'fill:' + marketId
            client.resolve(tradesArray, messageHash)

    def parse_ws_my_trade(self, trade: Any) -> Trade:
        #
        # {
        #   "id": "625138763437179034",
        #   "symbolName": "BTCUSDT_SPBL",
        #   "baseCoin": "BTC",
        #   "quoteCoin": "USDT",
        #   "orderId": "625138763307155610",
        #   "orderSide": "BUY",
        #   "fillSize": "0.000952",
        #   "fillValue": "99.9676160",
        #   "fillFee": "0.00000095",
        #   "direction": "TAKER",
        #   "createdTime": "1749044695720",
        #   "updatedTime": "1749044695720"
        # }
        #
        id = self.safe_string(trade, 'id')
        orderId = self.safe_string(trade, 'orderId')
        marketId = self.safe_string(trade, 'symbolName')
        market = self.safe_market(marketId)
        symbol = self.safe_string(market, 'symbol')
        timestamp = self.safe_integer(trade, 'createdTime')
        side = self.safe_string_lower(trade, 'orderSide')
        amount = self.safe_string(trade, 'fillSize')
        cost = self.safe_string(trade, 'fillValue')
        feeAmount = self.safe_string(trade, 'fillFee')
        direction = self.safe_string_lower(trade, 'direction')
        takerOrMaker = 'taker' if (direction == 'taker') else 'maker'
        baseCurrency = self.safe_string(trade, 'baseCoin')
        fee = {
            'cost': feeAmount,
            'currency': baseCurrency,
        }
        return self.safe_trade({
            'info': trade,
            'id': id,
            'order': orderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': None,
            'side': side,
            'amount': amount,
            'price': None,
            'cost': cost,
            'takerOrMaker': takerOrMaker,
            'fee': fee,
        }, market)

    def handle_orders(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "type": "trade-event",
        #   "channel": "orders",
        #   "msg": {
        #     "msgEvent": "OrderUpdate",
        #     "version": 38,
        #     "data": {
        #       "order": [
        #         {
        #           "id": "625138763307155610",
        #           "symbolName": "BTCUSDT_SPBL",
        #           "baseCoin": "BTC",
        #           "quoteCoin": "USDT",
        #           "orderSide": "BUY",
        #           "price": "0",
        #           "size": "0",
        #           "value": "100.0000000",
        #           "clientOrderId": "1749044695347g1xrdKa2xuDzbDHgTTkbubUoRd3x7s9c2I2mdtdj5qt7M6Evz5m",
        #           "type": "MARKET",
        #           "timeInForce": "IMMEDIATE_OR_CANCEL",
        #           "status": "FILLED",
        #           "cumFillSize": "0.000952",
        #           "cumFillValue": "99.9676160",
        #           "cumFillFee": "0.00000095",
        #           "createdTime": "1749044695689",
        #           "updatedTime": "1749044695720"
        #         }
        #       ]
        #     },
        #     "time": 1749044695720
        #   },
        #   "event": "payload"
        # }
        #
        msg = self.safe_dict(message, 'msg', {})
        data = self.safe_dict(msg, 'data', {})
        orders = self.safe_list(data, 'order', [])
        if self.orders is None:
            limit = self.safe_integer(self.options, 'ordersLimit', 1000)
            self.orders = ArrayCacheBySymbolById(limit)
        ordersArray = self.orders
        for i in range(0, len(orders)):
            order = orders[i]
            parsedOrder = self.parse_ws_order(order)
            ordersArray.append(parsedOrder)
        client.resolve(ordersArray, 'orders')
        # Resolve symbol-specific subscriptions
        for i in range(0, len(orders)):
            order = orders[i]
            marketId = self.safe_string(order, 'symbolName')
            messageHash = 'orders:' + marketId
            client.resolve(ordersArray, messageHash)

    def parse_ws_order(self, order: Any) -> Order:
        #
        # {
        #   "id": "625138763307155610",
        #   "symbolName": "BTCUSDT_SPBL",
        #   "baseCoin": "BTC",
        #   "quoteCoin": "USDT",
        #   "orderSide": "BUY",
        #   "price": "0",
        #   "size": "0",
        #   "value": "100.0000000",
        #   "clientOrderId": "1749044695347g1xrdKa2xuDzbDHgTTkbubUoRd3x7s9c2I2mdtdj5qt7M6Evz5m",
        #   "type": "MARKET",
        #   "timeInForce": "IMMEDIATE_OR_CANCEL",
        #   "status": "FILLED",
        #   "cumFillSize": "0.000952",
        #   "cumFillValue": "99.9676160",
        #   "cumFillFee": "0.00000095",
        #   "createdTime": "1749044695689",
        #   "updatedTime": "1749044695720"
        # }
        #
        id = self.safe_string(order, 'id')
        clientOrderId = self.safe_string(order, 'clientOrderId')
        marketId = self.safe_string(order, 'symbolName')
        market = self.safe_market(marketId)
        symbol = self.safe_string(market, 'symbol')
        timestamp = self.safe_integer(order, 'createdTime')
        lastUpdateTimestamp = self.safe_integer(order, 'updatedTime')
        type = self.safe_string_lower(order, 'type')
        side = self.safe_string_lower(order, 'orderSide')
        amount = self.safe_string_2(order, 'size', 'value')  # Use value for market orders
        price = self.safe_string(order, 'price')
        filled = self.safe_string(order, 'cumFillSize')
        cost = self.safe_string(order, 'cumFillValue')
        fee = {
            'cost': self.safe_string(order, 'cumFillFee'),
            'currency': self.safe_string(order, 'baseCoin'),
        }
        status = self.safe_string_lower(order, 'status')
        # Map WEEX status to CCXT status
        if status == 'new' or status == 'open':
            status = 'open'
        elif status == 'filled':
            status = 'closed'
        elif status == 'canceled' or status == 'cancelled':
            status = 'canceled'
        return self.safe_order({
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': lastUpdateTimestamp,
            'lastUpdateTimestamp': lastUpdateTimestamp,
            'symbol': symbol,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'amount': amount,
            'price': price,
            'stopPrice': None,
            'triggerPrice': None,
            'cost': cost,
            'average': None,
            'filled': filled,
            'remaining': None,
            'status': status,
            'fee': fee,
            'trades': None,
        }, market)

    def handle_balance(self, client: Client, message: Any) -> Any:
        #
        # {
        #   "type": "trade-event",
        #   "msg": {
        #     "msgEvent": "OrderUpdate",
        #     "version": 38,
        #     "data": {
        #       "accountAsset": [
        #         {
        #           "coinId": 1,
        #           "coinName": "BTC",
        #           "equity": "3.042645318000",
        #           "available": "3.042645318000",
        #           "frozen": "0"
        #         }
        #       ]
        #     },
        #     "time": 1749044695720
        #   },
        #   "channel": "account",
        #   "event": "payload"
        # }
        #
        msg = self.safe_dict(message, 'msg', {})
        data = self.safe_dict(msg, 'data', {})
        assets = self.safe_list(data, 'accountAsset', [])
        result: dict = {
            'info': message,
            'timestamp': self.safe_integer(msg, 'time'),
            'datetime': None,
        }
        result['datetime'] = self.iso8601(result['timestamp'])
        for i in range(0, len(assets)):
            asset = assets[i]
            currencyId = self.safe_string(asset, 'coinName')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_string(asset, 'available')
            account['used'] = self.safe_string(asset, 'frozen')
            account['total'] = self.safe_string(asset, 'equity')
            result[code] = account
        balance = self.safe_balance(result)
        client.resolve(balance, 'account')
